// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: inventoryItem.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItemToInventory = `-- name: AddItemToInventory :one
INSERT INTO
  inventory_item (
    inventory_id,
    item_id,
    position_x,
    position_y,
    rotation,
    quantity,
    created_at
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7)
RETURNING
  id, inventory_id, item_id, quantity, position_x, position_y, rotation, "durabilityLeft", created_at
`

type AddItemToInventoryParams struct {
	InventoryID pgtype.Int4
	ItemID      pgtype.Int4
	PositionX   pgtype.Int4
	PositionY   pgtype.Int4
	Rotation    pgtype.Int4
	Quantity    pgtype.Int4
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) AddItemToInventory(ctx context.Context, arg AddItemToInventoryParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, addItemToInventory,
		arg.InventoryID,
		arg.ItemID,
		arg.PositionX,
		arg.PositionY,
		arg.Rotation,
		arg.Quantity,
		arg.CreatedAt,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.InventoryID,
		&i.ItemID,
		&i.Quantity,
		&i.PositionX,
		&i.PositionY,
		&i.Rotation,
		&i.DurabilityLeft,
		&i.CreatedAt,
	)
	return i, err
}

const listInventoryItems = `-- name: ListInventoryItems :many
SELECT
  id, inventory_id, item_id, quantity, position_x, position_y, rotation, "durabilityLeft", created_at
FROM
  inventory_item
WHERE
  inventory_id = $1
ORDER BY
  id
`

func (q *Queries) ListInventoryItems(ctx context.Context, inventoryID pgtype.Int4) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, listInventoryItems, inventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.InventoryID,
			&i.ItemID,
			&i.Quantity,
			&i.PositionX,
			&i.PositionY,
			&i.Rotation,
			&i.DurabilityLeft,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeItemFromInventory = `-- name: RemoveItemFromInventory :one
DELETE FROM inventory_item
WHERE
  id = $1
RETURNING
  id, inventory_id, item_id, quantity, position_x, position_y, rotation, "durabilityLeft", created_at
`

func (q *Queries) RemoveItemFromInventory(ctx context.Context, id int32) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, removeItemFromInventory, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.InventoryID,
		&i.ItemID,
		&i.Quantity,
		&i.PositionX,
		&i.PositionY,
		&i.Rotation,
		&i.DurabilityLeft,
		&i.CreatedAt,
	)
	return i, err
}

const updateInventoryItem = `-- name: UpdateInventoryItem :one
UPDATE inventory_item
SET
  inventory_id = $1,
  item_id = $2,
  position_x = $3,
  position_y = $4,
  rotation = $5,
  quantity = $6,
  created_at = $7
WHERE
  id = $8
RETURNING
  id, inventory_id, item_id, quantity, position_x, position_y, rotation, "durabilityLeft", created_at
`

type UpdateInventoryItemParams struct {
	InventoryID pgtype.Int4
	ItemID      pgtype.Int4
	PositionX   pgtype.Int4
	PositionY   pgtype.Int4
	Rotation    pgtype.Int4
	Quantity    pgtype.Int4
	CreatedAt   pgtype.Timestamp
	ID          int32
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItem,
		arg.InventoryID,
		arg.ItemID,
		arg.PositionX,
		arg.PositionY,
		arg.Rotation,
		arg.Quantity,
		arg.CreatedAt,
		arg.ID,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.InventoryID,
		&i.ItemID,
		&i.Quantity,
		&i.PositionX,
		&i.PositionY,
		&i.Rotation,
		&i.DurabilityLeft,
		&i.CreatedAt,
	)
	return i, err
}
